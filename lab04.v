/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */
//=========================================================================
// Name & Email must be EXACTLY as in Gradescope roster!
// Name: Russell Kondoker
// Email: rkond005@ucr.edu
// 
// Assignment name: 
// Lab section: 
// TA: 
// 
// I hereby certify that I have not received assistance on this assignment,
// or used code, from ANY outside source other than the instruction team
// (apart from what was provided in the starter file).
//
//=========================================================================

//=========================================================================
//
// DO NOT CHANGE ANYTHING BELOW THIS COMMENT. IT IS PROVIDED TO MAKE SURE 
// YOUR LAB IS SUCCESSFULL. 
//
//=========================================================================

`timescale 1ns / 1ps

module gen_register (clk, rst, write_en, data_in, data_out);

parameter WORD_SIZE = 32 ; 

input wire clk , rst, write_en ;
input wire [WORD_SIZE-1:0] data_in ; 
output reg [WORD_SIZE-1:0] data_out; 

always @(posedge rst or posedge clk )
begin 

	if (rst)  begin 
		data_out <= { WORD_SIZE {1'b0} };
	end 
	else if (clk) begin
	
		if ( write_en )  begin 
			data_out  <= data_in ; 
		end 		
	end 

end 

endmodule

//=========================================================================
// Name & Email must be EXACTLY as in Gradescope roster!
// Name: 
// Email: 
// 
// Assignment name: 
// Lab section: 
// TA: 
// 
// I hereby certify that I have not received assistance on this assignment,
// or used code, from ANY outside source other than the instruction team
// (apart from what was provided in the starter file).
//
//=========================================================================

//=========================================================================
//
// DO NOT CHANGE ANYTHING BELOW THIS COMMENT. IT IS PROVIDED TO MAKE SURE 
// YOUR LAB IS SUCCESSFULL. 
//
//=========================================================================

`timescale 1ns / 1ps

`define MAX_REG 32
`define WORD_SIZE 32

module cpu_registers (
    input wire clk,	
    input wire rst , 
    input wire write_en,
    input wire [4:0] src1_addr,
    input wire [4:0] src2_addr, 
    input wire [4:0] dst_addr, 
    input wire [`WORD_SIZE-1:0]data_in    ,  
    output wire [`WORD_SIZE-1:0] src1_out  ,   
    output wire [`WORD_SIZE-1:0] src2_out  
);

// -----------------------------------------------
// Memory Words and Locations  
// ----------------------------------------------- 	
reg [`WORD_SIZE-1:0] RFILE [`MAX_REG-1:0];
integer i;

// --------------------------------------
// Read statements 
// -------------------------------------- 
assign src1_out = RFILE[src1_addr] ; 
assign src2_out = RFILE[src2_addr] ; 
	
// ---------------------------------------------
// Write  
// --------------------------------------------- 
always @(posedge clk)
begin 
    if (rst) begin 
        for (i = 0; i < `MAX_REG; i = i + 1) begin
            RFILE[i] <= { `WORD_SIZE {1'b0} } ; 
        end 
    end else begin 
        if (write_en) begin 
            RFILE[dst_addr] <= data_in;				
        end 	
    end
end
endmodule

//=========================================================================
// Name & Email must be EXACTLY as in Gradescope roster!
// Name: 
// Email: 
// 
// Assignment name: 
// Lab section: 
// TA: 
// 
// I hereby certify that I have not received assistance on this assignment,
// or used code, from ANY outside source other than the instruction team
// (apart from what was provided in the starter file).
//
//=========================================================================

//=========================================================================
//
// DO NOT CHANGE ANYTHING BELOW THIS COMMENT. IT IS PROVIDED TO MAKE SURE 
// YOUR LAB IS SUCCESSFULL. 
//
//=========================================================================

`timescale 1ns / 1ps

`define ALU_AND  		 4'b0000
`define ALU_OR   		 4'b0001
`define ALU_ADD  		 4'b0010
`define ALU_SUBTRACT   4'b0110
`define ALU_LESS_THAN  4'b0111
`define ALU_NOR        4'b1100

`define WORD_SIZE 32 

module alu (
	input wire [3:0] alu_control,  
	input wire [`WORD_SIZE-1:0] A, 
	input wire [`WORD_SIZE-1:0] B , 
	output reg zero, 
	output reg [`WORD_SIZE-1:0] result
);

reg [`WORD_SIZE-1:0] temp ; 

// ---------------------------------------------------------
// Parameters 
// --------------------------------------------------------- 

always @(alu_control or A or B) 
begin

	case (alu_control)   // R Type Instruction 	
		`ALU_AND :       result = A & B; 
		`ALU_OR :        result = A | B; 
		`ALU_ADD :       result = A + B; 
		`ALU_SUBTRACT :  result = A - B; 
		`ALU_NOR :       result = ~(A | B) ; 
		`ALU_LESS_THAN : result = $signed(A) < $signed(B) ?  1 : 0;
		
		default : temp = { `WORD_SIZE {1'b0} } ; 
	
	endcase

	// Final results 
	zero = (result == 0) ? 1 : 0; 
end 

endmodule


module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule

module DIG_RAMDualAccess
#(
    parameter Bits = 8,
    parameter AddrBits = 4
)
(
    input C, // Clock signal
    input ld,
    input [(AddrBits-1):0] \1A ,
    input [(AddrBits-1):0] \2A ,
    input [(Bits-1):0] \1Din ,
    input str,
    output [(Bits-1):0] \1D ,
    output [(Bits-1):0] \2D
);
    // CAUTION: uses distributed RAM
    reg [(Bits-1):0] memory [0:((1 << AddrBits)-1)];

    assign \1D = ld? memory[\1A ] : 'hz;
    assign \2D = memory[\2A ];

    always @ (posedge C) begin
        if (str)
            memory[\1A ] <= \1Din ;
    end

endmodule


//=========================================================================
// Name & Email must be EXACTLY as in Gradescope roster!
// Name: 
// Email: 
// 
// Assignment name: 
// Lab section: 
// TA: 
// 
// I hereby certify that I have not received assistance on this assignment,
// or used code, from ANY outside source other than the instruction team
// (apart from what was provided in the starter file).
//
//=========================================================================

//=========================================================================
//
// DO NOT CHANGE ANYTHING BELOW THIS COMMENT. IT IS PROVIDED TO MAKE SURE 
// YOUR LAB IS SUCCESSFULL. 
//
//=========================================================================

`timescale 1ns / 1ps

`define OPCODE_R_TYPE       6'b000000
`define OPCODE_LOAD_WORD    6'b100011
`define OPCODE_STORE_WORD   6'b101011
`define OPCODE_BRANCH_EQ    6'b000100
`define OPCODE_ADDI         6'b001000
 
module control_unit (
 input wire[5:0] instr_op   ,   
 output reg	 reg_dst    ,    
 output reg	 branch     ,  
 output reg  mem_read   ,   
 output reg	 mem_to_reg ,   
 output reg  [1:0]	 alu_op     ,  
 output reg  mem_write  ,    
 output reg	 alu_src    ,   
 output reg	 reg_write   );

always @(*)
begin 
	
    reg_dst     = 0;
    branch      = 0;
    mem_read    = 0;
    mem_to_reg  = 0;
    alu_op      = 0;
    mem_write   = 0;
    alu_src     = 0;
    reg_write   = 0;
	 
    case (instr_op)  

	   `OPCODE_R_TYPE :        
					
					begin 	
						reg_dst    = 1;
                  reg_write  = 1;
                  alu_op     = 2;
					end 
					
      `OPCODE_ADDI : 
						begin 
						 alu_src    = 1;
                   reg_write  = 1;
						end 
                                                
      `OPCODE_LOAD_WORD :  
						 begin 
							alu_src    = 1;
                     mem_to_reg = 1;
                     reg_write  = 1;
                     mem_read   = 1;
						 end  	
                                        
      `OPCODE_STORE_WORD :
						begin 
							alu_src    = 1;
							mem_write  = 1;
						end 
                                        
      `OPCODE_BRANCH_EQ :  
		
						begin 
							reg_dst  = 1;
							branch   = 1;
                     alu_op   = 1;
						end 	
                                        
      default :    branch = 0 ; 
        
    endcase;
	 
end 

endmodule

module DIG_BitExtender #(
    parameter inputBits = 2,
    parameter outputBits = 4
)
(
    input [(inputBits-1):0] in,
    output [(outputBits - 1):0] out
);
    assign out = {{(outputBits - inputBits){in[inputBits - 1]}}, in};
endmodule



//=========================================================================
// Name & Email must be EXACTLY as in Gradescope roster!
// Name: 
// Email: 
// 
// Assignment name: 
// Lab section: 
// TA: 
// 
// I hereby certify that I have not received assistance on this assignment,
// or used code, from ANY outside source other than the instruction team
// (apart from what was provided in the starter file).
//
//=========================================================================

//=========================================================================
//
// DO NOT CHANGE ANYTHING BELOW THIS COMMENT. IT IS PROVIDED TO MAKE SURE 
// YOUR LAB IS SUCCESSFULL. 
//
//=========================================================================

`timescale 1ns / 1ps

`define FUNCT_AND   		6'b100100
`define FUNCT_OR    		6'b100101
`define FUNCT_ADD   		6'b100000
`define FUNCT_SUBTRACT 	6'b100010
`define FUNCT_LESS_THAN 6'b101010
`define FUNCT_NOR 		6'b100111

`define ALU_AND  		 4'b0000
`define ALU_OR   		 4'b0001
`define ALU_ADD  		 4'b0010
`define ALU_SUBTRACT   4'b0110
`define ALU_LESS_THAN  4'b0111
`define ALU_NOR        4'b1100

module alu_control (	
	input wire [1:0]	alu_op,	
	input wire [5:0]	funct,	
	output reg [3:0] 	alu_control   
);

always @(*)
begin
	if (alu_op==2'b00) begin // LW and SW 
		alu_control = `ALU_ADD ; 
 	end else if (alu_op==2'b01) begin  // Branch 
		alu_control = `ALU_SUBTRACT ; 
 	end else begin 
		case (funct)   // R Type Instruction 
			`FUNCT_AND : 		 alu_control = `ALU_AND ; 
			`FUNCT_OR  : 		 alu_control = `ALU_OR ; 
			`FUNCT_ADD : 		 alu_control = `ALU_ADD ; 
			`FUNCT_SUBTRACT  : alu_control = `ALU_SUBTRACT ; 
			`FUNCT_LESS_THAN : alu_control = `ALU_LESS_THAN ; 
			`FUNCT_NOR  : 		 alu_control = `ALU_NOR ; 
			default    :       alu_control = `ALU_ADD ;      
	endcase 
  end // End else 

end  // End block 

endmodule


module lab04 (
  input clk,
  input rst,
  output [31:0] PC,
  output [5:0] opcode,
  output [4:0] src1_addr,
  output [31:0] src1_out,
  output [4:0] src2_addr,
  output [31:0] src2_out,
  output [4:0] dst_addr,
  output [31:0] dst_data
);
  wire [31:0] s0;
  wire [31:0] PC_temp;
  wire [5:0] opcode_temp;
  wire RegDst;
  wire branch;
  wire MemRead;
  wire Mem2Reg;
  wire [1:0] ALUop;
  wire MemWrite;
  wire ALUsrc;
  wire RegWrite;
  wire [4:0] src1_addr_temp;
  wire [4:0] src2_addr_temp;
  wire [4:0] dst_addr_temp;
  wire [31:0] dst_data_temp;
  wire [31:0] src1_out_temp;
  wire [31:0] src2_out_temp;
  wire [15:0] s1;
  wire [31:0] SignExt;
  wire [4:0] s2;
  wire [5:0] s3;
  wire [3:0] s4;
  wire [31:0] s5;
  wire zero;
  wire [31:0] ALUresult;
  wire [31:0] \1D ;
  wire [31:0] s6;
  wire s7;
  wire [31:0] s8;
  wire [31:0] s9;
  wire [7:0] s10;
  wire [7:0] s11;
  wire [31:0] s12;
  // gen_register
  gen_register gen_register_i0 (
    .clk( clk ),
    .rst( rst ),
    .write_en( clk ),
    .data_in( s0 ),
    .data_out( PC_temp )
  );
  // cpu_registers
  cpu_registers cpu_registers_i1 (
    .clk( clk ),
    .rst( rst ),
    .write_en( RegWrite ),
    .src1_addr( src1_addr_temp ),
    .src2_addr( src2_addr_temp ),
    .dst_addr( dst_addr_temp ),
    .data_in( dst_data_temp ),
    .src1_out( src1_out_temp ),
    .src2_out( src2_out_temp )
  );
  // alu
  alu alu_i2 (
    .alu_control( 4'b10 ),
    .A( PC_temp ),
    .B( 32'b100 ),
    .result( s6 )
  );
  assign s11 = PC_temp[9:2];
  // alu
  alu alu_i3 (
    .alu_control( s4 ),
    .A( src1_out_temp ),
    .B( s5 ),
    .zero( zero ),
    .result( ALUresult )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i4 (
    .sel( ALUsrc ),
    .in_0( src2_out_temp ),
    .in_1( SignExt ),
    .out( s5 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i5 (
    .sel( s7 ),
    .in_0( s6 ),
    .in_1( s8 ),
    .out( s0 )
  );
  // alu
  alu alu_i6 (
    .alu_control( 4'b10 ),
    .A( s6 ),
    .B( s9 ),
    .result( s8 )
  );
  // cpumemory
  DIG_RAMDualAccess #(
    .Bits(32),
    .AddrBits(8)
  )
  DIG_RAMDualAccess_i7 (
    .str( MemWrite ),
    .C( clk ),
    .ld( MemRead ),
    .\1A ( s10 ),
    .\1Din ( src2_out_temp ),
    .\2A ( s11 ),
    .\1D ( \1D  ),
    .\2D ( s12 )
  );
  assign s3 = s12[5:0];
  assign s1 = s12[15:0];
  assign s2 = s12[15:11];
  assign src2_addr_temp = s12[20:16];
  assign src1_addr_temp = s12[25:21];
  assign opcode_temp = s12[31:26];
  assign s10 = ALUresult[7:0];
  // control_unit
  control_unit control_unit_i8 (
    .instr_op( opcode_temp ),
    .reg_dst( RegDst ),
    .branch( branch ),
    .mem_read( MemRead ),
    .mem_to_reg( Mem2Reg ),
    .alu_op( ALUop ),
    .mem_write( MemWrite ),
    .alu_src( ALUsrc ),
    .reg_write( RegWrite )
  );
  DIG_BitExtender #(
    .inputBits(16),
    .outputBits(32)
  )
  DIG_BitExtender_i9 (
    .in( s1 ),
    .out( SignExt )
  );
  Mux_2x1_NBits #(
    .Bits(5)
  )
  Mux_2x1_NBits_i10 (
    .sel( RegDst ),
    .in_0( src2_addr_temp ),
    .in_1( s2 ),
    .out( dst_addr_temp )
  );
  // alu_control
  alu_control alu_control_i11 (
    .alu_op( ALUop ),
    .funct( s3 ),
    .alu_control( s4 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i12 (
    .sel( Mem2Reg ),
    .in_0( ALUresult ),
    .in_1( \1D  ),
    .out( dst_data_temp )
  );
  assign s7 = (branch & zero);
  assign s9[31:2] = SignExt[31:2];
  assign s9[1:0] = 2'b0;
  assign PC = PC_temp;
  assign opcode = opcode_temp;
  assign src1_addr = src1_addr_temp;
  assign src1_out = src1_out_temp;
  assign src2_addr = src2_addr_temp;
  assign src2_out = src2_out_temp;
  assign dst_addr = dst_addr_temp;
  assign dst_data = dst_data_temp;
endmodule
